#bayesianapproximator
def sample(self, s, a, n):
  s_idx = self.getIndex(s)
  mu, nu, alpha, beta = self.B[s_idx, a, :]
  df = beta * (nu + 1) / (nu * alpha)
  scale = beta
  variance = (df / (df - 2)) * math.pow(scale, 2.0)
  # don't add the mean here so we do not double count for the reward
  one_stdev = np.sqrt(variance)
  return [one_stdev]

#BNNApproximation
  def update_stats(self, s, a, val=0.0):
        if self.dimensions.shape != s.shape or not a <= self.num_actions:

            raise ValueError("Invalid value to update stats", s, a, val)
        input = np.concatenate((s, self.convert_action(a)))
        print(input.shape)

        self.bnn.fit(np.array([input, input]), np.array([val, val]), batch_size=32, epochs=100, verbose=1)
